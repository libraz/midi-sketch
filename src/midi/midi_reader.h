#pragma once

#include "core/types.h"
#include <cstdint>
#include <string>
#include <vector>

namespace midisketch {

// Note info for parsed MIDI
struct ParsedNote {
  uint8_t pitch = 0;
  uint8_t velocity = 0;
  Tick start = 0;
  Tick duration = 0;
};

// Parsed MIDI track info
struct ParsedTrack {
  std::string name;
  uint8_t channel = 0;
  uint8_t program = 0;
  std::vector<ParsedNote> notes;
};

// Parsed MIDI file info
struct ParsedMidi {
  uint16_t format = 0;
  uint16_t num_tracks = 0;
  uint16_t division = 480;  // Ticks per quarter note
  uint16_t bpm = 120;
  std::vector<ParsedTrack> tracks;
  std::string metadata;  // MIDISKETCH metadata (JSON) if present

  // Get track by name (case-insensitive)
  const ParsedTrack* getTrack(const std::string& name) const;

  // Check if this MIDI was generated by midi-sketch
  bool hasMidiSketchMetadata() const { return !metadata.empty(); }
};

// MIDI file reader
class MidiReader {
 public:
  MidiReader() = default;

  // Read MIDI file from path
  // Returns true on success, false on error
  bool read(const std::string& path);

  // Read MIDI from memory buffer
  bool read(const std::vector<uint8_t>& data);

  // Get parsed MIDI data
  const ParsedMidi& getParsedMidi() const { return midi_; }

  // Get last error message
  const std::string& getError() const { return error_; }

 private:
  ParsedMidi midi_;
  std::string error_;

  // Read variable-length quantity
  uint32_t readVariableLength(const uint8_t* data, size_t& offset, size_t max_size);

  // Parse header chunk
  bool parseHeader(const uint8_t* data, size_t size);

  // Parse track chunk
  bool parseTrack(const uint8_t* data, size_t size);
};

}  // namespace midisketch
