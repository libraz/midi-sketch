<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>midi-sketch Demo</title>
  <link href="https://unpkg.com/vuetify@3/dist/vuetify.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@7/css/materialdesignicons.min.css" rel="stylesheet">
  <style>
    .chord-key-display {
      font-family: monospace;
      background: #f5f5f5;
      padding: 8px 12px;
      border-radius: 4px;
      margin-top: 8px;
    }
    .piano-range {
      height: 24px;
      background: repeating-linear-gradient(
        90deg,
        #eceff1 0px, #eceff1 14px,
        #37474f 14px, #37474f 20px,
        #eceff1 20px, #eceff1 34px,
        #37474f 34px, #37474f 40px,
        #eceff1 40px, #eceff1 54px,
        #eceff1 54px, #eceff1 68px,
        #37474f 68px, #37474f 74px,
        #eceff1 74px, #eceff1 88px,
        #37474f 88px, #37474f 94px,
        #eceff1 94px, #eceff1 108px,
        #37474f 108px, #37474f 114px,
        #eceff1 114px, #eceff1 128px
      );
      background-size: 128px 100%;
      border-radius: 4px;
      position: relative;
      border: 1px solid #ccc;
    }
    .piano-highlight {
      position: absolute;
      height: 100%;
      background: rgba(33, 150, 243, 0.4);
      border-radius: 4px;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="app">
    <v-app>
      <v-main class="bg-grey-lighten-4">
        <v-container>
          <v-row>
            <v-col cols="12">
              <h1 class="text-h4 mb-2">
                midi-sketch
                <span class="text-subtitle-1 text-grey">v{{ version }}</span>
              </h1>
              <v-alert v-if="!ready" type="info" variant="tonal" class="mb-4">
                Loading WASM module...
              </v-alert>
              <v-alert v-else type="success" variant="tonal" class="mb-4">
                Ready
              </v-alert>
            </v-col>
          </v-row>

          <!-- Style & Structure -->
          <v-card class="mb-4">
            <v-card-title>Style & Structure</v-card-title>
            <v-card-text>
              <v-select
                v-model="config.stylePresetId"
                :items="styleItems"
                label="Style Preset"
                item-title="text"
                item-value="value"
                @update:model-value="onStyleChange"
              ></v-select>
              <div class="text-caption text-grey mb-4">{{ styleDescription }}</div>

              <v-row>
                <v-col cols="6">
                  <v-select
                    v-model="config.chordProgressionId"
                    :items="chordItems"
                    label="Chord Progression"
                    item-title="text"
                    item-value="value"
                  ></v-select>
                  <div class="text-caption text-grey">{{ chordRomanDisplay }}</div>
                  <div v-if="chordKeyDisplay" class="chord-key-display">
                    Key of {{ keyName }}: <strong>{{ chordKeyDisplay }}</strong>
                  </div>
                </v-col>
                <v-col cols="6">
                  <v-select
                    v-model="config.formId"
                    :items="formItems"
                    :disabled="config.targetDurationSeconds > 0"
                    label="Form"
                    item-title="text"
                    item-value="value"
                  ></v-select>
                </v-col>
              </v-row>

              <v-select
                v-model="config.key"
                :items="keyItems"
                label="Key"
                item-title="text"
                item-value="value"
              ></v-select>

              <!-- BPM Slider -->
              <div class="mt-4">
                <div class="d-flex justify-space-between align-center">
                  <span class="text-subtitle-2">BPM</span>
                  <span class="text-h6">{{ config.bpm }}</span>
                </div>
                <v-slider
                  v-model="config.bpm"
                  :min="60"
                  :max="180"
                  :step="1"
                  color="primary"
                  track-color="grey-lighten-2"
                  thumb-label
                ></v-slider>
                <div class="text-caption text-center" :class="bpmRecommendationClass">
                  {{ bpmRecommendation }}
                </div>
              </div>

              <!-- Duration -->
              <v-text-field
                v-model.number="config.targetDurationSeconds"
                label="Duration (seconds, 0 = use Form)"
                type="number"
                :min="0"
                :max="300"
                hint=""
                persistent-hint
              >
                <template v-slot:message>
                  {{ durationHint }}
                </template>
              </v-text-field>
            </v-card-text>
          </v-card>

          <!-- Vocal & Expression -->
          <v-card class="mb-4">
            <v-card-title>Vocal & Expression</v-card-title>
            <v-card-text>
              <div class="text-subtitle-2 mb-2">Vocal Range</div>
              <v-row>
                <v-col cols="6">
                  <v-slider
                    v-model="config.vocalLow"
                    :min="36"
                    :max="84"
                    :step="1"
                    label="Low"
                    thumb-label="always"
                    color="blue"
                  >
                    <template v-slot:thumb-label>{{ midiToNote(config.vocalLow) }}</template>
                  </v-slider>
                </v-col>
                <v-col cols="6">
                  <v-slider
                    v-model="config.vocalHigh"
                    :min="48"
                    :max="96"
                    :step="1"
                    label="High"
                    thumb-label="always"
                    color="blue"
                  >
                    <template v-slot:thumb-label>{{ midiToNote(config.vocalHigh) }}</template>
                  </v-slider>
                </v-col>
              </v-row>

              <!-- Piano visualization -->
              <div class="d-flex align-center ga-2 mb-2">
                <span class="text-caption">C2</span>
                <div class="piano-range flex-grow-1">
                  <div class="piano-highlight" :style="pianoHighlightStyle"></div>
                </div>
                <span class="text-caption">C7</span>
              </div>
              <div class="text-caption text-center text-grey">
                Range: {{ midiToNote(config.vocalLow) }} - {{ midiToNote(config.vocalHigh) }}
                ({{ config.vocalHigh - config.vocalLow }} semitones)
              </div>

              <v-row class="mt-4">
                <v-col cols="6">
                  <v-select
                    v-model="config.vocalAttitude"
                    :items="vocalAttitudeItems"
                    label="Vocal Style"
                    item-title="text"
                    item-value="value"
                  ></v-select>
                </v-col>
                <v-col cols="6">
                  <v-text-field
                    v-model.number="config.seed"
                    label="Seed (0 = random)"
                    type="number"
                    :min="0"
                  ></v-text-field>
                </v-col>
              </v-row>
            </v-card-text>
          </v-card>

          <!-- Options -->
          <v-card class="mb-4">
            <v-card-title>Options</v-card-title>
            <v-card-text>
              <v-row>
                <v-col cols="4">
                  <v-checkbox v-model="config.drumsEnabled" label="Drums" hide-details></v-checkbox>
                </v-col>
                <v-col cols="4">
                  <v-checkbox v-model="config.arpeggioEnabled" label="Arpeggio" hide-details></v-checkbox>
                </v-col>
                <v-col cols="4">
                  <v-checkbox v-model="config.humanize" label="Humanize" hide-details></v-checkbox>
                </v-col>
              </v-row>

              <v-expand-transition>
                <v-row v-if="config.humanize" class="mt-2">
                  <v-col cols="6">
                    <v-slider
                      v-model="config.humanizeTiming"
                      :min="0"
                      :max="100"
                      label="Timing"
                      thumb-label
                    ></v-slider>
                  </v-col>
                  <v-col cols="6">
                    <v-slider
                      v-model="config.humanizeVelocity"
                      :min="0"
                      :max="100"
                      label="Velocity"
                      thumb-label
                    ></v-slider>
                  </v-col>
                </v-row>
              </v-expand-transition>
            </v-card-text>
          </v-card>

          <!-- Actions -->
          <v-card class="mb-4">
            <v-card-title>Actions</v-card-title>
            <v-card-text>
              <v-btn-group>
                <v-btn color="primary" :disabled="!ready" @click="generate">
                  <v-icon start>mdi-music-note</v-icon>
                  Generate
                </v-btn>
                <v-btn color="secondary" :disabled="!midiData" @click="regenerateMelody">
                  <v-icon start>mdi-refresh</v-icon>
                  Regenerate
                </v-btn>
                <v-btn color="purple" :disabled="!midiData || isPlaying" @click="play">
                  <v-icon start>mdi-play</v-icon>
                  Play
                </v-btn>
                <v-btn color="error" :disabled="!isPlaying" @click="stop">
                  <v-icon start>mdi-stop</v-icon>
                  Stop
                </v-btn>
                <v-btn color="success" :disabled="!midiData" @click="downloadMidi">
                  <v-icon start>mdi-download</v-icon>
                  Download
                </v-btn>
              </v-btn-group>

              <v-progress-linear
                v-if="midiData"
                v-model="playbackProgress"
                class="mt-4"
                color="purple"
                height="8"
                rounded
              ></v-progress-linear>
              <div v-if="midiData" class="text-center text-caption mt-1">
                {{ formatTime(playbackTime) }} / {{ formatTime(totalDuration) }}
              </div>
            </v-card-text>
          </v-card>

          <!-- Result -->
          <v-card v-if="resultText">
            <v-card-title>Result</v-card-title>
            <v-card-text>
              <pre class="text-body-2">{{ resultText }}</pre>
            </v-card-text>
          </v-card>
        </v-container>
      </v-main>
    </v-app>
  </div>

  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <script src="https://unpkg.com/vuetify@3/dist/vuetify.min.js"></script>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <script type="module">
    import midisketch from '../dist/midisketch-wrapper.js';

    const { createApp, ref, computed, watch, onMounted } = Vue;
    const { createVuetify } = Vuetify;

    const vuetify = createVuetify();

    const NOTE_NAMES = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];
    const KEY_NAMES = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];

    createApp({
      setup() {
        // State
        const ready = ref(false);
        const version = ref('...');
        const stylePresets = ref([]);
        const allChords = ref([]);
        const allForms = ref([]);
        const chordIds = ref([]);
        const formIds = ref([]);

        const config = ref({
          stylePresetId: 0,
          key: 0,
          bpm: 120,
          seed: 0,
          chordProgressionId: 0,
          formId: 5,
          vocalAttitude: 0,
          drumsEnabled: true,
          arpeggioEnabled: false,
          vocalLow: 55,
          vocalHigh: 74,
          humanize: false,
          humanizeTiming: 50,
          humanizeVelocity: 50,
          targetDurationSeconds: 0
        });

        // Playback state
        const sketch = ref(null);
        const midiData = ref(null);
        const eventData = ref(null);
        const isPlaying = ref(false);
        const playbackTime = ref(0);
        const totalDuration = ref(0);
        const resultText = ref('');

        // Synths
        let synths = {};
        let scheduledEvents = [];
        let animationFrame = null;

        // Computed
        const styleItems = computed(() =>
          stylePresets.value.map(p => ({ text: p.displayName, value: p.id }))
        );

        const chordItems = computed(() =>
          chordIds.value.map(id => {
            const chord = allChords.value[id];
            return chord ? { text: chord.name, value: id } : null;
          }).filter(Boolean)
        );

        const formItems = computed(() =>
          formIds.value.map(id => {
            const form = allForms.value[id];
            return form ? { text: form.name, value: id } : null;
          }).filter(Boolean)
        );

        const keyItems = computed(() =>
          KEY_NAMES.map((name, i) => ({ text: name, value: i }))
        );

        const vocalAttitudeItems = computed(() => [
          { text: 'Clean', value: 0 },
          { text: 'Expressive', value: 1 },
          { text: 'Raw', value: 2 }
        ]);

        const currentPreset = computed(() =>
          stylePresets.value.find(p => p.id === config.value.stylePresetId)
        );

        const styleDescription = computed(() =>
          currentPreset.value?.description || ''
        );

        const keyName = computed(() => KEY_NAMES[config.value.key]);

        const chordRomanDisplay = computed(() => {
          const chord = allChords.value[config.value.chordProgressionId];
          return chord?.display || '';
        });

        const chordKeyDisplay = computed(() => {
          const display = chordRomanDisplay.value;
          if (!display) return '';
          return transposeChordDisplay(display, config.value.key);
        });

        const bpmRecommendation = computed(() => {
          if (!currentPreset.value) return '';
          const diff = Math.abs(config.value.bpm - currentPreset.value.tempoDefault);
          if (diff === 0) return '✓ Default for this style';
          if (diff <= 20) return `Style default: ${currentPreset.value.tempoDefault}`;
          return `⚠ Style default: ${currentPreset.value.tempoDefault}`;
        });

        const bpmRecommendationClass = computed(() => {
          if (!currentPreset.value) return '';
          const diff = Math.abs(config.value.bpm - currentPreset.value.tempoDefault);
          if (diff === 0) return 'text-success';
          if (diff <= 20) return 'text-grey';
          return 'text-warning';
        });

        const durationHint = computed(() => {
          const dur = config.value.targetDurationSeconds;
          if (dur === 0) return '0 = use Form pattern';
          const mins = Math.floor(dur / 60);
          const secs = dur % 60;
          const bars = Math.round(dur * config.value.bpm / 240);
          return `~${mins}:${secs.toString().padStart(2, '0')} (${bars} bars) - Form ignored`;
        });

        const pianoHighlightStyle = computed(() => {
          const low = config.value.vocalLow;
          const high = Math.max(low, config.value.vocalHigh);
          const startPercent = ((low - 36) / 60) * 100;
          const widthPercent = ((high - low) / 60) * 100;
          return { left: `${startPercent}%`, width: `${widthPercent}%` };
        });

        const playbackProgress = computed(() =>
          totalDuration.value > 0 ? (playbackTime.value / totalDuration.value) * 100 : 0
        );

        // Methods
        function midiToNote(midi) {
          const octave = Math.floor(midi / 12) - 1;
          return `${NOTE_NAMES[midi % 12]}${octave}`;
        }

        function transposeChordSymbol(symbol, key) {
          const chordMap = {
            'I': 0, 'II': 2, 'III': 4, 'IV': 5, 'V': 7, 'VI': 9, 'VII': 11,
            'i': 0, 'ii': 2, 'iii': 4, 'iv': 5, 'v': 7, 'vi': 9, 'vii': 11,
            'bII': 1, 'bIII': 3, 'bVI': 8, 'bVII': 10, '#IV': 6, '#iv': 6
          };
          const match = symbol.match(/^([b#]?)([IViv]+)(.*)/);
          if (!match) return symbol;
          const [, accidental, numeral, suffix] = match;
          const interval = chordMap[accidental + numeral];
          if (interval === undefined) return symbol;
          const rootNote = (key + interval) % 12;
          const isMinor = numeral === numeral.toLowerCase();
          let name = KEY_NAMES[rootNote];
          if (isMinor) name += 'm';
          if (suffix) name += suffix;
          return name;
        }

        function transposeChordDisplay(display, key) {
          return display.split(' - ').map(p => transposeChordSymbol(p.trim(), key)).join(' - ');
        }

        function formatTime(seconds) {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function onStyleChange() {
          const preset = currentPreset.value;
          if (!preset) return;

          config.value.bpm = preset.tempoDefault;
          chordIds.value = midisketch.getProgressionsByStyle(config.value.stylePresetId);
          formIds.value = midisketch.getFormsByStyle(config.value.stylePresetId);

          if (chordIds.value.length > 0) {
            config.value.chordProgressionId = chordIds.value[0];
          }
          if (formIds.value.length > 0) {
            config.value.formId = formIds.value[0];
          }
        }

        function initSynths() {
          Object.values(synths).forEach(s => s.dispose());
          synths = {
            vocal: new Tone.PolySynth(Tone.Synth, {
              oscillator: { type: 'triangle' },
              envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 0.4 }
            }).toDestination(),
            chord: new Tone.PolySynth(Tone.Synth, {
              oscillator: { type: 'sine' },
              envelope: { attack: 0.05, decay: 0.2, sustain: 0.4, release: 0.8 }
            }).toDestination(),
            bass: new Tone.MonoSynth({
              oscillator: { type: 'sawtooth' },
              envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.3 }
            }).toDestination(),
            drums: new Tone.MembraneSynth().toDestination(),
            arpeggio: new Tone.PolySynth(Tone.Synth, {
              oscillator: { type: 'sawtooth' },
              envelope: { attack: 0.01, decay: 0.15, sustain: 0.2, release: 0.3 }
            }).toDestination()
          };
          synths.vocal.volume.value = -6;
          synths.chord.volume.value = -12;
          synths.bass.volume.value = -8;
          synths.drums.volume.value = -4;
          synths.arpeggio.volume.value = -8;
        }

        function ticksToSeconds(ticks, bpm) {
          return (ticks / 480) * (60 / bpm);
        }

        async function generate() {
          try {
            stop();
            if (sketch.value) sketch.value.destroy();

            sketch.value = new midisketch.MidiSketch();
            sketch.value.generateFromConfig(config.value);

            midiData.value = sketch.value.getMidi();
            eventData.value = sketch.value.getEvents();

            const preset = currentPreset.value;
            const chord = allChords.value[config.value.chordProgressionId];

            totalDuration.value = ticksToSeconds(eventData.value.duration_ticks, eventData.value.bpm);

            resultText.value = [
              `Generated MIDI: ${midiData.value.length} bytes`,
              `Style: ${preset?.displayName}`,
              `Chord: ${chord?.display || 'N/A'}`,
              `BPM: ${eventData.value.bpm}`,
              `Duration: ${formatTime(totalDuration.value)}`
            ].join('\n');

          } catch (e) {
            resultText.value = `Error: ${e.message}`;
            console.error(e);
          }
        }

        function regenerateMelody() {
          if (!sketch.value) return;
          try {
            stop();
            sketch.value.regenerateMelody(config.value.seed === 0 ? Date.now() : config.value.seed);
            midiData.value = sketch.value.getMidi();
            eventData.value = sketch.value.getEvents();
            resultText.value = `Regenerated melody: ${midiData.value.length} bytes`;
          } catch (e) {
            resultText.value = `Error: ${e.message}`;
          }
        }

        async function play() {
          if (!eventData.value || isPlaying.value) return;
          try {
            await Tone.start();
            initSynths();
            isPlaying.value = true;

            const bpm = eventData.value.bpm;
            Tone.Transport.bpm.value = bpm;
            scheduledEvents.forEach(id => Tone.Transport.clear(id));
            scheduledEvents = [];

            eventData.value.tracks.forEach(track => {
              const synth = synths[track.name.toLowerCase()];
              if (!synth) return;

              track.notes.forEach(note => {
                const startTime = ticksToSeconds(note.start_ticks, bpm);
                const duration = ticksToSeconds(note.duration_ticks, bpm);
                const velocity = note.velocity / 127;
                const noteStr = Tone.Frequency(note.pitch, 'midi').toNote();

                const id = Tone.Transport.schedule(time => {
                  if (track.name.toLowerCase() === 'drums') {
                    synth.triggerAttackRelease(Tone.Frequency(note.pitch, 'midi').toFrequency(), duration, time, velocity);
                  } else {
                    synth.triggerAttackRelease(noteStr, duration, time, velocity);
                  }
                }, startTime);
                scheduledEvents.push(id);
              });
            });

            const endTime = ticksToSeconds(eventData.value.duration_ticks, bpm);
            scheduledEvents.push(Tone.Transport.schedule(() => stop(), endTime + 0.1));

            Tone.Transport.start();
            updateProgress();
          } catch (e) {
            console.error('Playback error:', e);
            stop();
          }
        }

        function updateProgress() {
          if (!isPlaying.value) return;
          playbackTime.value = Tone.Transport.seconds;
          animationFrame = requestAnimationFrame(updateProgress);
        }

        function stop() {
          isPlaying.value = false;
          Tone.Transport.stop();
          Tone.Transport.cancel();
          scheduledEvents.forEach(id => Tone.Transport.clear(id));
          scheduledEvents = [];
          if (animationFrame) cancelAnimationFrame(animationFrame);
          playbackTime.value = 0;
        }

        function downloadMidi() {
          if (!midiData.value) return;
          midisketch.downloadMidi(midiData.value, 'midi-sketch-output.mid');
        }

        // Initialize
        onMounted(async () => {
          try {
            await midisketch.init();
            version.value = midisketch.getVersion();
            stylePresets.value = midisketch.getStylePresets();
            allChords.value = midisketch.getChords();
            allForms.value = midisketch.getStructures();
            onStyleChange();
            ready.value = true;
          } catch (e) {
            console.error('Init error:', e);
          }
        });

        return {
          ready, version, config,
          styleItems, chordItems, formItems, keyItems, vocalAttitudeItems,
          styleDescription, keyName, chordRomanDisplay, chordKeyDisplay,
          bpmRecommendation, bpmRecommendationClass, durationHint,
          pianoHighlightStyle, playbackProgress, playbackTime, totalDuration,
          midiData, isPlaying, resultText,
          midiToNote, formatTime, onStyleChange,
          generate, regenerateMelody, play, stop, downloadMidi
        };
      }
    }).use(vuetify).mount('#app');
  </script>
</body>
</html>
