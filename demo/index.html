<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>midi-sketch Demo</title>
  <style>
    * { box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      max-width: 900px; margin: 0 auto; padding: 20px;
      background: #f5f5f5; color: #333;
    }
    h1 { color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; }
    .version { color: #7f8c8d; font-size: 0.9em; font-weight: normal; }
    .section {
      background: white; border-radius: 8px; padding: 20px;
      margin-bottom: 20px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .section h2 { margin-top: 0; color: #2c3e50; font-size: 1.2em; }
    .form-group { margin-bottom: 15px; }
    label { display: block; margin-bottom: 5px; font-weight: 500; color: #34495e; }
    select, input[type="number"] {
      width: 100%; padding: 10px; border: 1px solid #ddd;
      border-radius: 4px; font-size: 14px;
    }
    select:focus, input:focus { outline: none; border-color: #3498db; }
    select:disabled, input:disabled { background: #ecf0f1; color: #7f8c8d; cursor: not-allowed; }
    .row { display: flex; gap: 15px; flex-wrap: wrap; }
    .row > .form-group { flex: 1; min-width: 120px; }
    .checkbox-group { display: flex; align-items: center; gap: 10px; }
    .checkbox-group input { width: auto; }
    button {
      padding: 12px 24px; border: none; border-radius: 4px;
      font-size: 16px; cursor: pointer; transition: background 0.2s;
    }
    .btn-primary { background: #3498db; color: white; }
    .btn-primary:hover { background: #2980b9; }
    .btn-primary:disabled, .btn-secondary:disabled, .btn-play:disabled, .btn-stop:disabled {
      background: #bdc3c7; cursor: not-allowed;
    }
    .btn-secondary { background: #2ecc71; color: white; }
    .btn-secondary:hover { background: #27ae60; }
    .btn-play { background: #9b59b6; color: white; }
    .btn-play:hover { background: #8e44ad; }
    .btn-stop { background: #e74c3c; color: white; }
    .btn-stop:hover { background: #c0392b; }
    .btn-vocal { background: #f39c12; color: white; }
    .btn-vocal:hover { background: #d68910; }
    .btn-vocal:disabled { background: #bdc3c7; cursor: not-allowed; }
    .buttons { display: flex; gap: 10px; flex-wrap: wrap; }
    .workflow-toggle {
      display: flex; gap: 5px; margin-bottom: 15px;
      background: #ecf0f1; padding: 5px; border-radius: 4px;
    }
    .workflow-toggle button {
      flex: 1; padding: 8px 12px; font-size: 13px;
      background: transparent; border: none; border-radius: 4px;
      cursor: pointer; transition: all 0.2s;
    }
    .workflow-toggle button.active { background: #3498db; color: white; }
    .workflow-toggle button:not(.active):hover { background: #d5dbdb; }
    .workflow-toggle button:disabled { opacity: 0.5; cursor: not-allowed; }
    .workflow-toggle button:disabled:hover { background: transparent; }
    .workflow-hint { font-size: 0.85em; color: #7f8c8d; margin-bottom: 10px; }
    .result {
      background: #ecf0f1; padding: 15px; border-radius: 4px;
      font-family: monospace; font-size: 13px; white-space: pre-wrap;
    }
    .status { padding: 10px; border-radius: 4px; margin-bottom: 15px; }
    .status.loading { background: #fff3cd; color: #856404; }
    .status.ready { background: #d4edda; color: #155724; }
    .status.error { background: #f8d7da; color: #721c24; }
    .hint { color: #7f8c8d; font-size: 0.85em; margin-top: 5px; }
    .chord-key-display {
      font-family: monospace; background: #ecf0f1;
      padding: 4px 8px; border-radius: 4px; margin-top: 5px;
    }
    .playback-info {
      display: flex; align-items: center; gap: 15px; margin-top: 15px;
      padding: 10px; background: #ecf0f1; border-radius: 4px;
    }
    .progress-bar {
      flex: 1; height: 8px; background: #bdc3c7;
      border-radius: 4px; overflow: hidden;
    }
    .progress-bar-fill {
      height: 100%; background: #9b59b6; transition: width 0.1s linear;
    }
    .time-display { font-family: monospace; font-size: 14px; min-width: 100px; text-align: right; }
    .slider-group { margin-top: 10px; }
    .bpm-slider, .range-slider { width: 100%; }
    .bpm-value { text-align: center; font-weight: bold; font-size: 1.1em; color: #2c3e50; margin-top: 4px; }
    .bpm-rec { text-align: center; font-size: 0.8em; margin-top: 2px; }
    .vocal-range-visual { display: flex; align-items: center; gap: 10px; margin-top: 8px; }
    .piano-range {
      flex: 1; height: 24px; border-radius: 4px; position: relative; border: 1px solid #bdc3c7;
      background: repeating-linear-gradient(90deg,
        #ecf0f1 0px, #ecf0f1 14px, #34495e 14px, #34495e 20px,
        #ecf0f1 20px, #ecf0f1 34px, #34495e 34px, #34495e 40px,
        #ecf0f1 40px, #ecf0f1 54px, #ecf0f1 54px, #ecf0f1 68px,
        #34495e 68px, #34495e 74px, #ecf0f1 74px, #ecf0f1 88px,
        #34495e 88px, #34495e 94px, #ecf0f1 94px, #ecf0f1 108px,
        #34495e 108px, #34495e 114px, #ecf0f1 114px, #ecf0f1 128px
      );
      background-size: 128px 100%;
    }
    .piano-highlight {
      position: absolute; height: 100%; background: rgba(52, 152, 219, 0.5); border-radius: 4px;
    }
    .vocal-note { font-family: monospace; font-size: 0.9em; min-width: 40px; text-align: center; }
    .collapsible { cursor: pointer; user-select: none; }
    .collapsible:after { content: ' +'; }
    .collapsible.open:after { content: ' -'; }
    .collapsed { display: none; }
    .vocal-config-panel {
      margin-top: 15px; padding: 15px; background: #fff3cd;
      border-radius: 8px; border: 1px solid #ffc107;
    }
    .vocal-config-panel h3 { margin: 0 0 10px 0; font-size: 1em; color: #856404; }
    .vocal-config-panel .row { margin-bottom: 10px; }
    .vocal-config-panel .form-group { flex: 1; min-width: 100px; }
    .vocal-config-panel select, .vocal-config-panel input { padding: 6px; font-size: 13px; }
    .btn-tweak { background: #fd7e14; color: white; font-size: 14px; padding: 8px 12px; }
    .btn-tweak:hover { background: #e96b02; }
    .btn-tweak.active { background: #dc3545; }
    .mode-tabs {
      display: flex; gap: 0; margin-bottom: 20px; background: #2c3e50;
      border-radius: 8px; overflow: hidden;
    }
    .mode-tabs button {
      flex: 1; padding: 15px 20px; font-size: 16px; font-weight: 600;
      background: transparent; border: none; color: #95a5a6;
      cursor: pointer; transition: all 0.2s;
    }
    .mode-tabs button.active { background: #3498db; color: white; }
    .mode-tabs button:not(.active):hover { background: #34495e; color: white; }
  </style>
</head>
<body>
  <div id="app" v-scope @vue:mounted="init()">
    <h1>midi-sketch <span class="version">v{{ version }}</span></h1>
    <div :class="['status', status.type]">{{ status.text }}</div>

    <!-- Mode Tabs -->
    <div class="mode-tabs">
      <button :class="{ active: mode === 'vocal' }" @click="mode = 'vocal'; onModeChange()">Vocal Song</button>
      <button :class="{ active: mode === 'bgm' }" @click="mode = 'bgm'; onModeChange()">BGM</button>
    </div>

    <!-- ==================== VOCAL SONG MODE ==================== -->
    <div v-if="mode === 'vocal'">
      <!-- Style & Structure -->
      <div class="section">
        <h2>Style & Structure</h2>
        <div class="form-group">
          <label>Style Preset</label>
          <select v-model="config.stylePresetId" @change="onStyleChange">
            <option v-for="s in stylePresets" :value="s.id">{{ s.displayName }}</option>
          </select>
          <div class="hint">{{ currentPreset?.description }}</div>
        </div>

        <div class="row">
          <div class="form-group">
            <label>Blueprint</label>
            <select v-model.number="config.blueprintId" @change="onBlueprintChange">
              <option v-for="bp in allBlueprints" :value="bp.id">{{ bp.name }} ({{ bp.weight }}%)</option>
              <option :value="255">Random</option>
            </select>
            <div class="hint" v-if="currentBlueprint">{{ blueprintHint }}</div>
          </div>
          <div class="form-group">
            <label>Chord Progression</label>
            <select v-model="config.chordProgressionId" @change="updateChordDisplay">
              <option v-for="id in chordIds" :value="id">{{ allChords[id]?.name }}</option>
            </select>
            <div v-if="chordDisplay" class="hint">{{ chordDisplay.roman }}</div>
            <div v-if="chordDisplay" class="chord-key-display">
              Key of {{ keyName }}: <strong>{{ chordDisplay.transposed }}</strong>
            </div>
          </div>
          <div class="form-group">
            <label>Form</label>
            <select v-model="config.formId" :disabled="config.targetDurationSeconds > 0 || blueprintOverridesForm">
              <option v-for="id in formIds" :value="id">{{ allForms[id]?.name }}</option>
            </select>
            <div v-if="blueprintOverridesForm" class="hint" style="color: #e67e22;">Overridden by Blueprint</div>
          </div>
        </div>

        <div class="row">
          <div class="form-group">
            <label>Key</label>
            <select v-model="config.key" @change="updateChordDisplay">
              <option v-for="(k, i) in keyNames" :value="i">{{ k }}</option>
            </select>
          </div>
          <div class="form-group">
            <label>BPM</label>
            <input type="range" class="bpm-slider" v-model.number="config.bpm" min="60" max="180">
            <div class="bpm-value">{{ config.bpm }} BPM</div>
            <div class="bpm-rec" :style="{ color: bpmRecColor }">{{ bpmRec }}</div>
          </div>
          <div class="form-group">
            <label>Duration (0 = Form)</label>
            <input type="number" v-model.number="config.targetDurationSeconds" min="0" max="300" step="30">
            <div class="hint">{{ durationHint }}</div>
          </div>
        </div>

        <div class="form-group">
          <label>Seed (0 = random)</label>
          <input type="number" v-model.number="config.seed" min="0">
        </div>
      </div>

      <!-- Vocal & Expression -->
      <div class="section">
        <h2>Vocal & Expression</h2>
        <div class="form-group">
          <label>Vocal Range</label>
          <div class="row">
            <div class="form-group">
              <label style="font-size:0.85em">Low</label>
              <input type="range" v-model.number="config.vocalLow" min="36" max="84" class="range-slider">
              <div class="vocal-note">{{ midiToNote(config.vocalLow) }}</div>
            </div>
            <div class="form-group">
              <label style="font-size:0.85em">High</label>
              <input type="range" v-model.number="config.vocalHigh" min="48" max="96" class="range-slider">
              <div class="vocal-note">{{ midiToNote(effectiveVocalHigh) }}</div>
            </div>
          </div>
          <div class="vocal-range-visual">
            <span style="font-size:0.8em;color:#7f8c8d">C2</span>
            <div class="piano-range">
              <div class="piano-highlight" :style="pianoHighlightStyle"></div>
            </div>
            <span style="font-size:0.8em;color:#7f8c8d">C7</span>
          </div>
          <div class="hint" style="text-align:center;margin-top:8px">
            {{ midiToNote(config.vocalLow) }} - {{ midiToNote(effectiveVocalHigh) }}
            ({{ effectiveVocalHigh - config.vocalLow }} semitones)
          </div>
        </div>

        <div class="row">
          <div class="form-group">
            <label>Vocal Style</label>
            <select v-model.number="config.vocalStyle">
              <option v-for="vs in vocalStyles" :value="vs.value">{{ vs.text }}</option>
            </select>
          </div>
          <div class="form-group">
            <label>Vocal Attitude</label>
            <select v-model="config.vocalAttitude">
              <option v-for="a in vocalAttitudes" :value="a.value" :disabled="a.disabled">{{ a.text }}</option>
            </select>
          </div>
        </div>
      </div>
    </div>

    <!-- ==================== BGM MODE ==================== -->
    <div v-if="mode === 'bgm'">
      <!-- Style & Structure -->
      <div class="section">
        <h2>Style & Structure</h2>
        <div class="row">
          <div class="form-group">
            <label>Style Preset</label>
            <select v-model="config.stylePresetId" @change="onStyleChange">
              <option v-for="s in stylePresets" :value="s.id">{{ s.displayName }}</option>
            </select>
            <div class="hint">{{ currentPreset?.description }}</div>
          </div>
          <div class="form-group">
            <label>BGM Type</label>
            <select v-model.number="config.compositionStyle" @change="onBgmTypeChange">
              <option value="1">Background Motif</option>
              <option value="2">Synth Driven</option>
            </select>
            <div class="hint">{{ bgmTypeHint }}</div>
          </div>
        </div>

        <div class="row">
          <div class="form-group">
            <label>Chord Progression</label>
            <select v-model="config.chordProgressionId" @change="updateChordDisplay">
              <option v-for="id in chordIds" :value="id">{{ allChords[id]?.name }}</option>
            </select>
            <div v-if="chordDisplay" class="hint">{{ chordDisplay.roman }}</div>
            <div v-if="chordDisplay" class="chord-key-display">
              Key of {{ keyName }}: <strong>{{ chordDisplay.transposed }}</strong>
            </div>
          </div>
          <div class="form-group">
            <label>Form</label>
            <select v-model="config.formId" :disabled="config.targetDurationSeconds > 0">
              <option v-for="id in formIds" :value="id">{{ allForms[id]?.name }}</option>
            </select>
          </div>
        </div>

        <div class="row">
          <div class="form-group">
            <label>Key</label>
            <select v-model="config.key" @change="updateChordDisplay">
              <option v-for="(k, i) in keyNames" :value="i">{{ k }}</option>
            </select>
          </div>
          <div class="form-group">
            <label>BPM</label>
            <input type="range" class="bpm-slider" v-model.number="config.bpm" min="60" max="180">
            <div class="bpm-value">{{ config.bpm }} BPM</div>
            <div class="bpm-rec" :style="{ color: bpmRecColor }">{{ bpmRec }}</div>
          </div>
          <div class="form-group">
            <label>Duration (0 = Form)</label>
            <input type="number" v-model.number="config.targetDurationSeconds" min="0" max="300" step="30">
            <div class="hint">{{ durationHint }}</div>
          </div>
        </div>

        <div class="form-group">
          <label>Seed (0 = random)</label>
          <input type="number" v-model.number="config.seed" min="0">
        </div>
      </div>
    </div>

    <!-- Modulation & Arrangement (both modes) -->
    <div class="section">
      <h2 class="collapsible" :class="{ open: showAdvanced }" @click="showAdvanced = !showAdvanced">
        Modulation & Arrangement
      </h2>
      <div :class="{ collapsed: !showAdvanced }">
        <div class="row">
          <div class="form-group">
            <label>Modulation Timing</label>
            <select v-model.number="config.modulationTiming">
              <option value="0">None</option>
              <option value="1">Last Chorus</option>
              <option value="2">After Bridge</option>
              <option value="3">Each Chorus</option>
              <option value="4">Random</option>
            </select>
          </div>
          <div class="form-group">
            <label>Modulation Semitones</label>
            <input type="number" v-model.number="config.modulationSemitones" min="1" max="4" :disabled="!modulationEnabled">
            <div v-if="modulationWarning" class="hint" style="color: #e74c3c;">{{ modulationWarning }}</div>
            <div v-else-if="!modulationEnabled" class="hint">Enable modulation timing first</div>
          </div>
        </div>
        <div class="row">
          <div class="form-group">
            <label>Arrangement Growth</label>
            <select v-model="config.arrangementGrowth">
              <option value="0">Layer Add</option>
              <option value="1">Register Add</option>
            </select>
          </div>
          <div class="form-group" v-if="mode === 'vocal'">
            <label>Motif Scope</label>
            <select v-model="config.motifRepeatScope" :disabled="blueprintOverridesMotifScope">
              <option value="0">Full Song</option>
              <option value="1">Section</option>
            </select>
            <div v-if="blueprintOverridesMotifScope" class="hint" style="color: #e67e22;">Overridden by Blueprint</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Options (mode-aware) -->
    <div class="section">
      <h2>Options</h2>
      <div class="row">
        <div class="form-group"><div class="checkbox-group">
          <input type="checkbox" id="drums" v-model="config.drumsEnabled" :disabled="mode === 'vocal' && blueprintRequiresDrums">
          <label for="drums">Drums</label>
          <span v-if="mode === 'vocal' && blueprintRequiresDrums" style="font-size:0.8em;color:#7f8c8d">(required)</span>
        </div></div>
        <div class="form-group"><div class="checkbox-group">
          <input type="checkbox" id="arpeggio" v-model="config.arpeggioEnabled" :disabled="mode === 'bgm' && config.compositionStyle === 2">
          <label for="arpeggio">Arpeggio</label>
          <span v-if="mode === 'bgm' && config.compositionStyle === 2" style="font-size:0.8em;color:#7f8c8d">(required)</span>
        </div></div>
        <div class="form-group"><div class="checkbox-group">
          <input type="checkbox" id="humanize" v-model="config.humanize"><label for="humanize">Humanize</label>
        </div></div>
        <div class="form-group"><div class="checkbox-group">
          <input type="checkbox" id="se" v-model="config.seEnabled"><label for="se">SE</label>
        </div></div>
        <div class="form-group" v-if="mode === 'vocal'"><div class="checkbox-group">
          <input type="checkbox" id="call" v-model="config.callEnabled"><label for="call">Call</label>
        </div></div>
      </div>

      <div v-if="config.humanize" class="slider-group row">
        <div class="form-group">
          <label>Timing {{ config.humanizeTiming }}%</label>
          <input type="range" v-model.number="config.humanizeTiming" min="0" max="100" class="range-slider">
        </div>
        <div class="form-group">
          <label>Velocity {{ config.humanizeVelocity }}%</label>
          <input type="range" v-model.number="config.humanizeVelocity" min="0" max="100" class="range-slider">
        </div>
      </div>

      <div v-if="config.arpeggioEnabled" class="slider-group row">
        <div class="form-group">
          <label>Arpeggio Speed</label>
          <select v-model.number="config.arpeggioSpeed">
            <option value="0">1/8</option>
            <option value="1">1/16</option>
            <option value="2">1/32</option>
          </select>
        </div>
        <div class="form-group">
          <label>Octave Range</label>
          <input type="number" v-model.number="config.arpeggioOctaveRange" min="1" max="4">
        </div>
        <div class="form-group"><div class="checkbox-group">
          <input type="checkbox" id="arpsync" v-model="config.arpeggioSyncChord">
          <label for="arpsync">Sync Chord</label>
        </div></div>
      </div>

      <div v-if="mode === 'vocal' && config.callEnabled" class="slider-group row">
        <div class="form-group">
          <label>Intro Chant</label>
          <select v-model.number="config.introChant">
            <option value="0">None</option>
            <option value="1">Gachikoi</option>
            <option value="2">Shouting</option>
          </select>
        </div>
        <div class="form-group">
          <label>Mix Pattern</label>
          <select v-model.number="config.mixPattern">
            <option value="0">None</option>
            <option value="1">Standard</option>
            <option value="2">Tiger</option>
          </select>
        </div>
        <div class="form-group">
          <label>Call Density</label>
          <select v-model.number="config.callDensity">
            <option value="0">None</option>
            <option value="1">Minimal</option>
            <option value="2">Standard</option>
            <option value="3">Intense</option>
          </select>
        </div>
      </div>
    </div>

    <!-- Actions -->
    <div class="section">
      <h2>Actions</h2>

      <!-- Vocal Song Mode -->
      <div v-if="mode === 'vocal'">
        <div class="workflow-toggle">
          <button :class="{ active: workflow === 'vocalFirst' }" @click="workflow = 'vocalFirst'">Vocal First</button>
          <button :class="{ active: workflow === 'fullGenerate' }" @click="workflow = 'fullGenerate'">Full Generate</button>
        </div>
        <div class="workflow-hint">{{ workflowHint }}</div>

        <!-- Vocal First Workflow -->
        <div v-if="workflow === 'vocalFirst'" class="buttons">
          <button class="btn-vocal" :disabled="!ready" @click="generateVocal">1. Vocal Only</button>
          <button class="btn-vocal" :disabled="!hasVocalOnly" @click="regenerateVocal">New Seed</button>
          <button :class="['btn-tweak', { active: showVocalConfig }]" :disabled="!hasVocalOnly" @click="showVocalConfig = !showVocalConfig">Tweak</button>
          <button class="btn-primary" :disabled="!hasVocalOnly" @click="generateAccompaniment">2. Add Accompaniment</button>
          <button class="btn-play" :disabled="!midiData || isPlaying" @click="play">Play</button>
          <button class="btn-stop" :disabled="!isPlaying" @click="stop">Stop</button>
          <button class="btn-secondary" :disabled="!midiData" @click="downloadMidi">Download</button>
        </div>

        <!-- Vocal Config Panel -->
        <div v-if="workflow === 'vocalFirst' && hasVocalOnly && showVocalConfig" class="vocal-config-panel">
          <h3>Vocal Regeneration Settings</h3>
          <div class="row">
            <div class="form-group">
              <label>Vocal Low</label>
              <select v-model.number="vocalConfig.vocalLow">
                <option v-for="n in vocalNoteOptions" :value="n.value">{{ n.text }}</option>
              </select>
            </div>
            <div class="form-group">
              <label>Vocal High</label>
              <select v-model.number="vocalConfig.vocalHigh">
                <option v-for="n in vocalNoteOptions" :value="n.value">{{ n.text }}</option>
              </select>
            </div>
            <div class="form-group">
              <label>Attitude</label>
              <select v-model.number="vocalConfig.vocalAttitude">
                <option value="0">Clean</option>
                <option value="1">Expressive</option>
                <option value="2">Raw</option>
              </select>
            </div>
          </div>
          <div class="row">
            <div class="form-group">
              <label>Vocal Style</label>
              <select v-model.number="vocalConfig.vocalStyle">
                <option v-for="vs in vocalStyles" :value="vs.value">{{ vs.text }}</option>
              </select>
            </div>
            <div class="form-group">
              <label>Complexity</label>
              <select v-model.number="vocalConfig.melodicComplexity">
                <option value="0">Simple</option>
                <option value="1">Standard</option>
                <option value="2">Complex</option>
              </select>
            </div>
            <div class="form-group">
              <label>Hook</label>
              <select v-model.number="vocalConfig.hookIntensity">
                <option value="0">Off</option>
                <option value="1">Light</option>
                <option value="2">Normal</option>
                <option value="3">Strong</option>
              </select>
            </div>
          </div>
          <div class="row">
            <div class="form-group">
              <label>Groove</label>
              <select v-model.number="vocalConfig.vocalGroove">
                <option value="0">Straight</option>
                <option value="1">OffBeat</option>
                <option value="2">Swing</option>
                <option value="3">Syncopated</option>
                <option value="4">Driving16th</option>
                <option value="5">Bouncy8th</option>
              </select>
            </div>
            <div class="form-group" style="flex: 2;">
              <label>&nbsp;</label>
              <button class="btn-vocal" style="width: 100%;" @click="regenerateVocalWithConfig">Regenerate with Settings</button>
            </div>
          </div>
        </div>

        <!-- Full Generate Workflow -->
        <div v-if="workflow === 'fullGenerate'" class="buttons">
          <button class="btn-primary" :disabled="!ready" @click="generateFull">Generate</button>
          <button class="btn-play" :disabled="!midiData || isPlaying" @click="play">Play</button>
          <button class="btn-stop" :disabled="!isPlaying" @click="stop">Stop</button>
          <button class="btn-secondary" :disabled="!midiData" @click="downloadMidi">Download</button>
        </div>
      </div>

      <!-- BGM Mode -->
      <div v-if="mode === 'bgm'">
        <div class="workflow-hint">Generate instrumental BGM (no vocal).</div>
        <div class="buttons">
          <button class="btn-primary" :disabled="!ready" @click="generateBgmOnly">Generate BGM</button>
          <button class="btn-play" :disabled="!midiData || isPlaying" @click="play">Play</button>
          <button class="btn-stop" :disabled="!isPlaying" @click="stop">Stop</button>
          <button class="btn-secondary" :disabled="!midiData" @click="downloadMidi">Download</button>
        </div>
      </div>

      <div v-if="midiData" class="playback-info">
        <div class="progress-bar">
          <div class="progress-bar-fill" :style="{ width: playbackProgress + '%' }"></div>
        </div>
        <div class="time-display">{{ formatTime(playbackTime) }} / {{ formatTime(totalDuration) }}</div>
      </div>
    </div>

    <!-- Result -->
    <div v-if="resultText" class="section">
      <h2>Result</h2>
      <div class="result">{{ resultText }}</div>
    </div>
  </div>

  <script src="https://unpkg.com/petite-vue@0.4.1/dist/petite-vue.iife.js"></script>
  <script type="module">
    import * as midisketch from '../dist/index.js';

    const NOTE_NAMES = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B'];

    // Simple Web Audio synth
    function midiToFreq(midi) {
      return 440 * Math.pow(2, (midi - 69) / 12);
    }

    function createSimpleSynth(audioContext) {
      const gainNode = audioContext.createGain();
      gainNode.gain.value = 0.3;
      gainNode.connect(audioContext.destination);
      const activeOscs = [];

      return {
        play(pitch, startTime, duration, velocity = 100) {
          const osc = audioContext.createOscillator();
          const env = audioContext.createGain();
          osc.type = 'triangle';
          osc.frequency.value = midiToFreq(pitch);
          env.gain.value = 0;
          osc.connect(env);
          env.connect(gainNode);

          const vol = (velocity / 127) * 0.5;
          // Attack
          env.gain.setValueAtTime(0, startTime);
          env.gain.linearRampToValueAtTime(vol, startTime + 0.02);
          // Sustain & Release
          env.gain.setValueAtTime(vol, startTime + duration - 0.05);
          env.gain.linearRampToValueAtTime(0, startTime + duration);

          osc.start(startTime);
          osc.stop(startTime + duration + 0.1);
          activeOscs.push(osc);
          // Auto-cleanup
          osc.onended = () => {
            const idx = activeOscs.indexOf(osc);
            if (idx !== -1) activeOscs.splice(idx, 1);
          };
        },
        stopAll() {
          const now = audioContext.currentTime;
          activeOscs.forEach(osc => {
            try { osc.stop(now); } catch (e) {}
          });
          activeOscs.length = 0;
        }
      };
    }

    PetiteVue.createApp({
      // State
      version: '...',
      ready: false,
      status: { type: 'loading', text: 'Loading WASM module...' },
      stylePresets: [],
      allChords: [],
      allForms: [],
      chordIds: [],
      formIds: [],
      keyNames: NOTE_NAMES,
      showAdvanced: false,
      vocalAttitudes: [
        { value: 0, text: 'Clean', disabled: false },
        { value: 1, text: 'Expressive', disabled: false },
        { value: 2, text: 'Raw', disabled: false }
      ],
      vocalStyles: [
        { value: 0, text: 'Auto' },
        { value: 1, text: 'Standard' },
        { value: 2, text: 'Vocaloid' },
        { value: 3, text: 'UltraVocaloid' },
        { value: 4, text: 'Idol' },
        { value: 5, text: 'Ballad' },
        { value: 6, text: 'Rock' },
        { value: 7, text: 'CityPop' },
        { value: 8, text: 'Anime' },
        { value: 9, text: 'BrightKira' },
        { value: 10, text: 'CoolSynth' },
        { value: 11, text: 'CuteAffected' },
        { value: 12, text: 'PowerfulShout' }
      ],
      config: {
        stylePresetId: 0, key: 0, bpm: 120, seed: 0,
        chordProgressionId: 0, formId: 5, vocalAttitude: 0, vocalStyle: 0,
        drumsEnabled: true, arpeggioEnabled: false,
        arpeggioSpeed: 1, arpeggioOctaveRange: 2, arpeggioGate: 80,
        arpeggioSyncChord: true,
        vocalLow: 55, vocalHigh: 74, skipVocal: false,
        humanize: false, humanizeTiming: 50, humanizeVelocity: 50,
        compositionStyle: 0, targetDurationSeconds: 0,
        modulationTiming: 0, modulationSemitones: 2,
        seEnabled: true, callEnabled: false, callNotesEnabled: true,
        introChant: 0, mixPattern: 0, callDensity: 2,
        arrangementGrowth: 0, motifRepeatScope: 0,
        motifFixedProgression: true, motifMaxChordCount: 4,
        blueprintId: 0
      },
      chordDisplay: null,
      sketch: null,
      midiData: null,
      eventData: null,
      isPlaying: false,
      playbackTime: 0,
      totalDuration: 0,
      resultText: '',
      mode: 'vocal',  // 'vocal' or 'bgm'
      workflow: 'vocalFirst',
      hasVocalOnly: false,
      showVocalConfig: false,
      vocalConfig: {
        seed: 0,
        vocalLow: 55,
        vocalHigh: 74,
        vocalAttitude: 0,
        vocalStyle: 0,
        melodicComplexity: 1,
        hookIntensity: 2,
        vocalGroove: 0,
        compositionStyle: 0
      },
      vocalNoteOptions: (() => {
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        const options = [];
        for (let n = 36; n <= 96; n++) {
          const noteName = notes[n % 12];
          const octave = Math.floor(n / 12) - 1;
          options.push({ value: n, text: `${noteName}${octave} (${n})` });
        }
        return options;
      })(),
      allBlueprints: [],
      // Blueprints that require drums (ID: 1, 5, 6, 7) per spec
      DRUMS_REQUIRED_BLUEPRINTS: [1, 5, 6, 7],
      // Blueprints that override formId (non-Traditional)
      FORM_OVERRIDE_BLUEPRINTS: [1, 2, 3, 4, 5, 6, 7, 8],

      // Internal (Web Audio)
      audioContext: null,
      synth: null,
      animationFrame: null,
      playStartTime: 0,
      stopTimeout: null,

      // Computed-like getters
      get currentPreset() {
        return this.stylePresets.find(p => p.id === this.config.stylePresetId);
      },
      get keyName() {
        return NOTE_NAMES[this.config.key];
      },
      get effectiveVocalHigh() {
        return Math.max(this.config.vocalLow, this.config.vocalHigh);
      },
      get pianoHighlightStyle() {
        const low = this.config.vocalLow;
        const high = this.effectiveVocalHigh;
        return { left: `${((low - 36) / 60) * 100}%`, width: `${((high - low) / 60) * 100}%` };
      },
      get bpmRec() {
        const p = this.currentPreset;
        if (!p) return '';
        const diff = Math.abs(this.config.bpm - p.tempoDefault);
        if (diff === 0) return '\u2713 Default';
        return `${diff > 20 ? '\u26a0 ' : ''}Default: ${p.tempoDefault}`;
      },
      get bpmRecColor() {
        const p = this.currentPreset;
        if (!p) return '#7f8c8d';
        const diff = Math.abs(this.config.bpm - p.tempoDefault);
        return diff === 0 ? '#27ae60' : diff <= 20 ? '#7f8c8d' : '#e67e22';
      },
      get durationHint() {
        const d = this.config.targetDurationSeconds;
        if (d === 0) return 'Use Form';
        const bars = Math.round(d * this.config.bpm / 240);
        return `~${Math.floor(d/60)}:${(d%60).toString().padStart(2,'0')} (${bars} bars)`;
      },
      get playbackProgress() {
        return this.totalDuration > 0 ? (this.playbackTime / this.totalDuration) * 100 : 0;
      },
      get workflowHint() {
        if (this.workflow === 'vocalFirst') {
          return 'Step 1: Generate vocal only. Try different seeds. Step 2: Add accompaniment when satisfied.';
        }
        return 'Generate full song with vocal and accompaniment in one step.';
      },
      // Blueprint drums_required: ID 1, 5, 6, 7 require drums
      get blueprintRequiresDrums() {
        return this.DRUMS_REQUIRED_BLUEPRINTS.includes(this.config.blueprintId);
      },
      // Non-Traditional blueprints override formId with section_flow
      get blueprintOverridesForm() {
        return this.FORM_OVERRIDE_BLUEPRINTS.includes(this.config.blueprintId);
      },
      // BGM mode based on tab selection
      get isBgmMode() {
        return this.mode === 'bgm';
      },
      // BGM type hint
      get bgmTypeHint() {
        if (this.config.compositionStyle === 1) return 'Instrumental with background motif patterns';
        if (this.config.compositionStyle === 2) return 'Instrumental with arpeggio-driven synth';
        return '';
      },
      // Modulation enabled means timing != 0
      get modulationEnabled() {
        return this.config.modulationTiming !== 0;
      },
      // Modulation validation warning
      get modulationWarning() {
        if (this.modulationEnabled && (this.config.modulationSemitones < 1 || this.config.modulationSemitones > 4)) {
          return 'Semitones should be 1-4 when modulation is enabled';
        }
        return '';
      },
      // Current blueprint info
      get currentBlueprint() {
        return this.allBlueprints.find(b => b.id === this.config.blueprintId);
      },
      get blueprintHint() {
        const bp = this.currentBlueprint;
        if (!bp) return 'Random selection based on weights';
        const paradigms = ['Traditional', 'RhythmSync', 'MelodyDriven'];
        const policies = ['Free', 'Locked', 'LockedPitch', 'LockedAll', 'Evolving'];
        let hint = `${paradigms[bp.paradigm] || '?'}, ${policies[bp.riffPolicy] || '?'}`;
        if (this.blueprintRequiresDrums) hint += ' (drums required)';
        if (this.blueprintOverridesForm) hint += ' (form override)';
        return hint;
      },
      // Blueprint riff policy overrides motifRepeatScope when not Free
      get blueprintOverridesMotifScope() {
        const bp = this.currentBlueprint;
        // RiffPolicy: 0=Free, others are Locked/LockedPitch/LockedAll/Evolving
        return bp && bp.riffPolicy !== 0;
      },

      // Methods
      midiToNote(midi) {
        return `${NOTE_NAMES[midi % 12]}${Math.floor(midi / 12) - 1}`;
      },
      formatTime(s) {
        return `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;
      },
      ticksToSeconds(ticks, bpm) {
        return (ticks / 480) * (60 / bpm);
      },

      transposeChord(symbol, key) {
        const map = { I:0,II:2,III:4,IV:5,V:7,VI:9,VII:11,i:0,ii:2,iii:4,iv:5,v:7,vi:9,vii:11,bII:1,bIII:3,bVI:8,bVII:10,'#IV':6,'#iv':6 };
        const m = symbol.match(/^([b#]?)([IViv]+)(.*)/);
        if (!m) return symbol;
        const interval = map[m[1] + m[2]];
        if (interval === undefined) return symbol;
        const root = (key + interval) % 12;
        let name = NOTE_NAMES[root];
        if (m[2] === m[2].toLowerCase()) name += 'm';
        return name + m[3];
      },

      updateChordDisplay() {
        const chord = this.allChords[this.config.chordProgressionId];
        if (!chord?.display) { this.chordDisplay = null; return; }
        const transposed = chord.display.split(' - ').map(p => this.transposeChord(p.trim(), this.config.key)).join(' - ');
        this.chordDisplay = { roman: chord.display, transposed };
      },

      updateVocalAttitudes() {
        const flags = this.currentPreset?.allowedAttitudes || 7;
        this.vocalAttitudes[0].disabled = !(flags & 1);
        this.vocalAttitudes[1].disabled = !(flags & 2);
        this.vocalAttitudes[2].disabled = !(flags & 4);
        for (const a of this.vocalAttitudes) {
          if (!a.disabled) { this.config.vocalAttitude = a.value; break; }
        }
      },

      onStyleChange() {
        const p = this.currentPreset;
        if (!p) return;
        this.config.bpm = p.tempoDefault;
        this.chordIds = midisketch.getProgressionsByStyle(this.config.stylePresetId);
        this.formIds = midisketch.getFormsByStyle(this.config.stylePresetId);
        if (this.chordIds.length) this.config.chordProgressionId = this.chordIds[0];
        if (this.formIds.length) this.config.formId = this.formIds[0];
        this.updateVocalAttitudes();
        this.updateChordDisplay();
      },

      onBlueprintChange() {
        // When blueprint requires drums, force drumsEnabled=true
        if (this.blueprintRequiresDrums) {
          this.config.drumsEnabled = true;
        }
      },

      onModeChange() {
        // When switching to BGM mode, set default compositionStyle and enable arpeggio for SynthDriven
        if (this.mode === 'bgm') {
          if (this.config.compositionStyle === 0) {
            this.config.compositionStyle = 1; // Default to BackgroundMotif
          }
          if (this.config.compositionStyle === 2) {
            this.config.arpeggioEnabled = true;
          }
        } else {
          // Vocal mode uses MelodyLead
          this.config.compositionStyle = 0;
        }
      },

      onBgmTypeChange() {
        // SynthDriven forces arpeggio enabled
        if (this.config.compositionStyle === 2) {
          this.config.arpeggioEnabled = true;
        }
      },

      initAudio() {
        if (!this.audioContext) {
          this.audioContext = new AudioContext();
        }
        this.synth = createSimpleSynth(this.audioContext);
      },

      generateFull() {
        try {
          this.stop();
          if (this.sketch) this.sketch.destroy();
          this.sketch = new midisketch.MidiSketch();
          this.sketch.generateFromConfig(this.config);
          this.midiData = this.sketch.getMidi();
          this.eventData = this.sketch.getEvents();
          this.totalDuration = this.ticksToSeconds(this.eventData.duration_ticks, this.eventData.bpm);
          this.hasVocalOnly = false;
          const p = this.currentPreset;
          const c = this.allChords[this.config.chordProgressionId];
          this.resultText = `Generated: ${this.midiData.length} bytes\nStyle: ${p?.displayName}\nChord: ${c?.display || 'N/A'}\nBPM: ${this.eventData.bpm}\nDuration: ${this.formatTime(this.totalDuration)}`;
        } catch (e) {
          this.resultText = `Error: ${e.message}`;
          console.error(e);
        }
      },

      generateBgmOnly() {
        try {
          this.stop();
          if (this.sketch) this.sketch.destroy();
          this.sketch = new midisketch.MidiSketch();
          const bgmConfig = { ...this.config, skipVocal: true };
          this.sketch.generateFromConfig(bgmConfig);
          this.midiData = this.sketch.getMidi();
          this.eventData = this.sketch.getEvents();
          this.totalDuration = this.ticksToSeconds(this.eventData.duration_ticks, this.eventData.bpm);
          this.hasVocalOnly = false;
          const p = this.currentPreset;
          const c = this.allChords[this.config.chordProgressionId];
          this.resultText = `BGM Generated: ${this.midiData.length} bytes\nStyle: ${p?.displayName}\nChord: ${c?.display || 'N/A'}\nBPM: ${this.eventData.bpm}\nDuration: ${this.formatTime(this.totalDuration)}`;
        } catch (e) {
          this.resultText = `Error: ${e.message}`;
          console.error(e);
        }
      },

      generateVocal() {
        try {
          this.stop();
          if (this.sketch) this.sketch.destroy();
          this.sketch = new midisketch.MidiSketch();
          this.sketch.generateVocal(this.config);
          this.midiData = this.sketch.getMidi();
          this.eventData = this.sketch.getEvents();
          this.totalDuration = this.ticksToSeconds(this.eventData.duration_ticks, this.eventData.bpm);
          this.hasVocalOnly = true;
          this.showVocalConfig = false;
          // Initialize vocalConfig from current config
          this.vocalConfig.vocalLow = this.config.vocalLow;
          this.vocalConfig.vocalHigh = this.config.vocalHigh;
          this.vocalConfig.vocalAttitude = this.config.vocalAttitude;
          this.vocalConfig.vocalStyle = this.config.vocalStyle;
          this.vocalConfig.compositionStyle = this.config.compositionStyle;
          const vocalTrack = this.eventData.tracks.find(t => t.name === 'Vocal');
          const noteCount = vocalTrack?.notes?.length || 0;
          this.resultText = `Vocal Only: ${noteCount} notes\nBPM: ${this.eventData.bpm}\nDuration: ${this.formatTime(this.totalDuration)}\n\nTry different seeds or tweak settings, then add accompaniment.`;
        } catch (e) {
          this.resultText = `Error: ${e.message}`;
          console.error(e);
        }
      },

      regenerateVocal() {
        if (!this.sketch || !this.hasVocalOnly) return;
        try {
          this.stop();
          const newSeed = Date.now();
          this.sketch.regenerateVocal(newSeed);
          this.midiData = this.sketch.getMidi();
          this.eventData = this.sketch.getEvents();
          const vocalTrack = this.eventData.tracks.find(t => t.name === 'Vocal');
          const noteCount = vocalTrack?.notes?.length || 0;
          this.resultText = `Vocal regenerated (seed: ${newSeed})\n${noteCount} notes`;
        } catch (e) {
          this.resultText = `Error: ${e.message}`;
        }
      },

      regenerateVocalWithConfig() {
        if (!this.sketch || !this.hasVocalOnly) return;
        try {
          this.stop();
          const newSeed = Date.now();
          this.sketch.regenerateVocal({
            seed: newSeed,
            vocalLow: this.vocalConfig.vocalLow,
            vocalHigh: this.vocalConfig.vocalHigh,
            vocalAttitude: this.vocalConfig.vocalAttitude,
            vocalStyle: this.vocalConfig.vocalStyle,
            melodicComplexity: this.vocalConfig.melodicComplexity,
            hookIntensity: this.vocalConfig.hookIntensity,
            vocalGroove: this.vocalConfig.vocalGroove,
            compositionStyle: this.vocalConfig.compositionStyle
          });
          this.midiData = this.sketch.getMidi();
          this.eventData = this.sketch.getEvents();
          const vocalTrack = this.eventData.tracks.find(t => t.name === 'Vocal');
          const noteCount = vocalTrack?.notes?.length || 0;
          const attNames = ['Clean', 'Expressive', 'Raw'];
          this.resultText = `Vocal regenerated with settings:\n` +
            `Range: ${this.midiToNote(this.vocalConfig.vocalLow)}-${this.midiToNote(this.vocalConfig.vocalHigh)}\n` +
            `Attitude: ${attNames[this.vocalConfig.vocalAttitude]}\n` +
            `${noteCount} notes`;
        } catch (e) {
          this.resultText = `Error: ${e.message}`;
          console.error(e);
        }
      },

      generateAccompaniment() {
        if (!this.sketch || !this.hasVocalOnly) return;
        try {
          this.stop();
          this.sketch.generateAccompaniment();
          this.midiData = this.sketch.getMidi();
          this.eventData = this.sketch.getEvents();
          this.hasVocalOnly = false;
          const p = this.currentPreset;
          const c = this.allChords[this.config.chordProgressionId];
          this.resultText = `Complete: ${this.midiData.length} bytes\nStyle: ${p?.displayName}\nChord: ${c?.display || 'N/A'}\nBPM: ${this.eventData.bpm}\nDuration: ${this.formatTime(this.totalDuration)}`;
        } catch (e) {
          this.resultText = `Error: ${e.message}`;
        }
      },

      async play() {
        if (!this.eventData || this.isPlaying) return;
        try {
          this.initAudio();
          const ctx = this.audioContext;
          if (ctx.state === 'suspended') await ctx.resume();

          const bpm = this.eventData.bpm;
          const now = ctx.currentTime + 0.1; // Small buffer
          this.playStartTime = now;

          console.log('Playing:', { bpm, tracks: this.eventData.tracks.map(t => ({ name: t.name, notes: t.notes?.length })) });

          let noteCount = 0;
          for (const track of this.eventData.tracks) {
            const trackName = track.name.toLowerCase();
            // Skip drums and SE for now (simple synth only)
            if (trackName === 'drums' || trackName === 'se') continue;

            for (const note of track.notes || []) {
              const start = this.ticksToSeconds(note.start_ticks, bpm);
              const dur = Math.max(0.1, this.ticksToSeconds(note.duration_ticks, bpm));
              this.synth.play(note.pitch, now + start, dur, note.velocity);
              noteCount++;
            }
          }
          console.log('Scheduled', noteCount, 'notes');

          this.isPlaying = true;
          this.totalDuration = this.ticksToSeconds(this.eventData.duration_ticks, bpm);
          // Auto-stop
          this.stopTimeout = setTimeout(() => this.stop(), this.totalDuration * 1000 + 500);
          this.updateProgress();
        } catch (e) {
          console.error('Playback error:', e);
          this.stop();
        }
      },

      updateProgress() {
        if (!this.isPlaying || !this.audioContext) return;
        this.playbackTime = this.audioContext.currentTime - this.playStartTime;
        if (this.playbackTime >= this.totalDuration) {
          this.stop();
          return;
        }
        this.animationFrame = requestAnimationFrame(() => this.updateProgress());
      },

      stop() {
        this.isPlaying = false;
        if (this.stopTimeout) {
          clearTimeout(this.stopTimeout);
          this.stopTimeout = null;
        }
        if (this.synth) {
          this.synth.stopAll();
        }
        if (this.animationFrame) {
          cancelAnimationFrame(this.animationFrame);
          this.animationFrame = null;
        }
        this.playbackTime = 0;
      },

      downloadMidi() {
        if (this.midiData) midisketch.downloadMidi(this.midiData, 'midi-sketch-output.mid');
      },

      async init() {
        try {
          await midisketch.init({ wasmPath: '../dist/midisketch.wasm' });
          this.version = midisketch.getVersion();
          this.stylePresets = midisketch.getStylePresets();
          this.allChords = midisketch.getChords();
          this.allForms = midisketch.getStructures();
          this.allBlueprints = midisketch.getBlueprints();
          this.onStyleChange();
          this.status = { type: 'ready', text: 'Ready' };
          this.ready = true;
        } catch (e) {
          this.status = { type: 'error', text: `Error: ${e.message}` };
          console.error(e);
        }
      }
    }).mount('#app');
  </script>
</body>
</html>
